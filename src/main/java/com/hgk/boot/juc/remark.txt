1.lock和synchronized的区别是什么
Lock是一个接口，显示锁，synchronized是一个关键字,隐式锁。
Lock不会主动加锁释放锁，是人为操作锁的。而synchronized是自动加锁释放锁的，在方法执行完或者异常时会释放锁。
Lock发生异常时不会主动释放锁，所以需要在try-finaly里去主动释放锁。而synchronized在发生异常时会释放锁。
多线程竞争越激烈，Lock的性能要优与synchronized
2.多线程编程步骤：
    创建资源类=>资源类中判断，干活，唤醒=>创建多线程调用资源类的方法=>防止虚假唤醒问题
3.wait()方法存在什么问题？
  1>虚假唤醒问题：
  例如伪代码 method sync (){
    if(num != 1){ this.wait(); }
    do something
  }
  当判断num!=1时，该线程A进入wait状态。然后其他的某个线程B在运行，B运行完，A又抢到锁，此时A开始执行时不会再判断
  num，而是运行后面的do something操作。要使用while回去重新判断。wait的特点，在哪里等待，被唤醒时，就在哪里开始执行。
4.ReentrantLock多个condition和单个condition有啥区别？//TODO
5.synchronized具体表现形式有哪几种？
  普通同步方法，锁的是当前对象
  静态同步方法，锁的是当前类的class
  同步方法块，锁是synchronized()括号里配置的对象
6.synchronized锁的8种情况？
7.公平锁和非公平锁
8.可重入锁（递归锁）和不可重入锁
  多个锁嵌套，获得最外层锁后，可以进入内层锁(同一把锁)的代码区域，就是可重入锁，synchronized和Lock都是可重入锁。
9.如何证明synchronized和Lock是可重入锁？
10.死锁的原因？
11.如何验证是否死锁？
    jps -l  --- 查看当前程序运行的进程
    jstack 进程号 --- 查看jvm堆栈信息。
12.创建线程的方式有哪些？
   继承Thread类
   实现Runnable接口
   Callable接口
   线程池
13.并发和并行
并发是同一时间多个人做同一件事，并行是一个人同时做多件事情
14.JMM是什么，谈谈JMM。
   JMM是一种抽象的概念，是一个规范。要求保证可见性。原子性。有序性
   各个线程对主内存的共享变量操作，都是各个线程各自拷贝到自己的工作内存进行操作，再写回到主内存。
15.volatile是什么？有哪些特性
volatile是轻量级的同步机制(就是乞丐版的synchronized)。三大特性：1>保证可见性。2>不保证原子性。3>禁止指令重排
这里内存有两个概念：主物理内存和线程的工作内存
一个线程修改了主内存的值，立马通知其他的线程知道它修改了，就是可见性。
16.什么是可见性？原子性？
可见性：当一个线程修改了一个共享变量后，其他线程也知道这个共享变量被修改了。
原子性：一个线程的操作不能被其他线程打断，同一时间只有一个线程对同一个变量进行操作。
17.sleep和wait有啥区别
sleep是Thread类的方法，不会释放锁，也不需要占有锁。
wait是Object类的方法，调用它的前提是必须占有锁。
18.Thread.yield()的作用
让当前线程从运行状态转为就绪状态。
19.单例模式在多线程下会发生什么？怎么解决？
发生：多个线程调用获取单例的方法getInstance()，结果不再是单例，会创建多个实例。
解决1.可以对getInstance()方法加synchronized关键字。
解决2.双端检测单例机制（double check lock(DCL)
    可以在getInstance()方法里面，加synchronized(类名.class)代码块,并在前后都检测instance是否为空。
19.1 双端检测单例机制一定线程安全吗？
   可能会出现指令重排，造成创建多个实例，线程不安全。
20.如何解决volatile不保证原子性造成的问题？
不保证原子性会造成数据丢失。解决方案一使用Atomic***相关类。解决方案二使用synchronized，但是太重了。
21.什么是指令重排？什么情况下会出现指令重排？怎么解决指令重排造成的问题？
指令重排就是底层cpu执行指令的顺序不一定按照代码的顺序执行，中间经过重新排序，顺序可能已经乱了。
单线程不需要考虑指令重排问题，是按代码顺序执行的。
多线程下，会出现指令重排，可以加volatile禁止指令重排。
22.i++线程安全吗？不安全
23.CAS是什么？作用是什么？什么情况会用CAS？底层原理是什么？
CAS英文compare and ,比较并交换。
作用：多线程下保证线程的原子性，同一时间只有一个线程对同一个变量操作修改。
场景：多线程下修改某个变量值的时候
底层原理：先了解三个变量：主内存变量值，工作内存快照值，更新值
每次修改前（写入主内存前），都会判断主内存变量值和工作内存快照值的值，如果相等，就会修改。
24.AtomiceInteger为什么不用synchronized而用CAS保证原子性？

