1.lock和synchronized的区别是什么
Lock是一个接口，显示锁，synchronized是一个关键字,隐式锁。
Lock不会主动加锁释放锁，是认为操作锁的。而synchronized是自动加锁释放锁的，在方法执行完或者异常时会释放锁。
Lock发生异常时不会主动释放锁，所以需要在try-finaly里去主动释放锁。而synchronized在发生异常时会释放锁。
多线程竞争越激烈，Lock的性能要优与synchronized
2.多线程编程步骤：
    创建资源类=>资源类中判断，干活，唤醒=>创建多线程调用资源类的方法=>防止虚假唤醒问题
3.wait()方法存在什么问题？
  1>虚假唤醒问题：
  例如伪代码 method sync (){
    if(num != 1){ this.wait(); }
    do something
  }
  当判断num!=1时，该线程A进入wait状态。然后其他的某个线程B在运行，B运行完，A又抢到锁，此时A开始执行时不会再判断
  num，而是运行后面的do something操作。要使用while回去重新判断。wait的特点，在哪里等待，被唤醒时，就在哪里开始执行。
4.ReentrantLock多个condition和单个condition有啥区别？//TODO
5.synchronized具体表现形式有哪几种？
  普通同步方法，锁的是当前对象
  静态同步方法，锁的是当前类的class
  同步方法块，锁是synchronized()括号里配置的对象
6.synchronized锁的8种情况？
7.公平锁和非公平锁
8.可重入锁（递归锁）和不可重入锁
  多个锁嵌套，获得最外层锁后，可以进入内层锁(同一把锁)的代码区域，就是可重入锁，synchronized和Lock都是可重入锁。
9.如何证明synchronized和Lock是可重入锁？
10.死锁的原因？
11.如何验证是否死锁？
    jps -l  --- 查看当前程序运行的进程
    jstack 进程号 --- 查看jvm堆栈信息。
12.创建线程的方式有哪些？
   继承Thread类
   实现Runnable接口
   Callable接口
   线程池
13.并发和并行
并发是同一时间多个人做同一件事，并行是一个人同时做多件事情
14.JMM是什么，谈谈JMM。
   JMM是一种抽象的概念，是一个规范。要求保证可见性。原子性。有序性
   各个线程对主内存的共享变量操作，都是各个线程各自拷贝到自己的工作内存进行操作，再写回到主内存。
15.volatile是什么？有哪些特性
volatile是轻量级的同步机制(就是乞丐版的synchronized)。三大特性：1>保证可见性。2>不保证原子性。3>禁止指令重排
这里内存有两个概念：主物理内存和线程的工作内存
一个线程修改了主内存的值，立马通知其他的线程知道它修改了，就是可见性。
16.什么是可见性？
当一个线程修改了一个共享变量后，其他线程也知道这个共享变量被修改了。
17.sleep和wait有啥区别
sleep是Thread类的方法，不会释放锁，也不需要占有锁。
wait是Object类的方法，调用它的前提是必须占有锁。
18.Thread.yield()的作用
让当前线程从运行状态转为就绪状态。