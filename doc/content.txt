模糊问题记录
1.在hashmap中怎么理解hash碰撞？
    其实就是hash(k1) = hash(k2)，然后计算存放的数组位置index=(n-1) & hash，可以看到k1和k2最终都存放到了一个数组下标中，就造成了碰撞。
但是一个数组下标又不能存多个元素，怎么解决这个碰撞呢？使用拉链法，将这两个元素使用链表结构存储。
2.hashmap的大小为什么是2的幂次方？
第一点：节省空间，减少hash碰撞的几率。怎么理解呢？我们知道哈希表索引index的计算方法为 tab[index=(n-1) & hash]，
当数组长度n为16时，此时减1为15（0000 1111），然后例如有一个hash为0110 0011，与操作的结果数组索引一定在0-15之间，并且0到15的每个位置
都可能被用到，不会浪费空间。
而如果不是2的次幂，我们看看会发生什么，举个例子：
数组长度为20（0001 0100），此时减1为19（0001 0011），hash为0110 1111，与操作的结果数组索引一定在0-19之间，但是一部分索引值永远都不会
取到，比如4，8，12等，浪费了数组的空间，并且还增加了hash碰撞的几率。
第二点：我们知道hashmap的初始大小为16（0001 0000），当hashmap要扩大2倍的时候，只需要位操作左移一位即可，位操作的速度很快。
4.hashmap数组为什么需要扩容？
当元素数量很多的时候，而数组长度一直为16，就会导致数组上的链表长度很长，会影响put和get元素的效率。
5.hashmap在jdk1.7和1.8的区别
第一点：hash函数算法不一样，1.8效率变得更高了
第二点：1.7先扩容在添加元素，1.8相反
第三点：1.7是数组+链表，1.8是数组+链表+红黑树
第四点：1.7是头插法，1.8是尾插法
6.tableSizeFor的作用什么？
返回一个大于等于输入参数并且为2的n次幂的最小整数
tableSizeFor(5) = 8
tableSizeFor(25) = 32
7.hashmap和hashtable的区别是什么？
线程安全问题：hashmap是线程不安全的，hashtable是线程安全的，因为hashtable在方法上面都加了synchronized关键字。
键值为null问题：hashmap键值都可以为null，但是为null的键只能有一个，值为null的可以有多个。hashtable键值都不可以为null。
扩容大小问题：未自定义容量时，hashtable初始容量为11，扩容为原来的2n+1。hashmap初始容量为16，每次扩容变为原来的2倍。
    自定义容量时，hashtable直接使用这个容量。hashmap则会取大于等于这个数的2的幂次方的最小整数。
底层数据结构：hashtable就是数组+链表。而hashmap是数组+链表+红黑树，当链表长度大于等于阈值8时，会先判断数组长度是不是小于64，
    如果小于64，会先对数组扩容,否则，会将链表转化为红黑树。
8.hashmap和treemap的区别是什么？

